
#version 460

#define WORK_GROUP_SIZE 32

layout (local_size_x = WORK_GROUP_SIZE) in;

#define PARTICLE_RADIUS 0.005f

uniform int Number_Particles;
uniform mat4 m_model;
uniform int Pause;
uniform float MASS;
uniform float RESTDENSITY;
uniform int HASHSIZE;
uniform int PONTOS_LADO;
uniform float H;
uniform vec4 GRAVITY;
uniform float BALLDENSITY;
uniform float BALLR;
uniform float TIMESTEP;

uniform float XMAX;
uniform float YMAX;
uniform float ZMAX;
uniform float XMIN;
uniform float YMIN;
uniform float ZMIN;

layout(std430, binding = 0) buffer Position
{
    vec4 position[];
};



layout(std430, binding = 1) buffer TempPosition
{
    vec4 tempPosition[];
};

layout(std430, binding = 2) buffer Index
{
    uint bufferIndex[];
};

layout(std430, binding = 3) buffer TempIndex
{
    uint tempIndex[];
};

layout(std430, binding = 4) buffer BallPos
{
    vec4 ballPos[];
};

layout(std430, binding = 5) buffer BallForce
{
    ivec4 ballForce[];
};

layout(std430, binding = 6) buffer Debug
{
    vec4 debug[];
};


//Morton code --------------------------------------------



uint part1by2(uint n) {
    n &= 0x000003ff;
    n = (n ^ (n << 16)) & 0xff0000ff;
    n = (n ^ (n << 8)) & 0x0300f00f;
    n = (n ^ (n << 4)) & 0x030c30c3;
    n = (n ^ (n << 2)) & 0x09249249;
    return n;
}


uint unpart1by2(uint n) {
    n &= 0x09249249;
    n = (n ^ (n >> 2)) & 0x030c30c3;
    n = (n ^ (n >> 4)) & 0x0300f00f;
    n = (n ^ (n >> 8)) & 0xff0000ff;
    n = (n ^ (n >> 16)) & 0x000003ff;
    return n;
}


uint  interleave3(uint x, uint y, uint z) {
    return part1by2(x) | (part1by2(y) << 1) | (part1by2(z) << 2);
}


void deinterleave3(uint n, uint x, uint y, uint z) {
    x = unpart1by2(n);
    y = unpart1by2(n >> 1);
    z = unpart1by2(n >> 2);
}

//Morton code --------------------------------------------


void main()
{
    
    if (Pause == 1)
        return;

    uint index = gl_GlobalInvocationID.x;
    
    if (index==1){

        vec4 bf =ballForce[0] / 1000;

        vec4 totalFoces = GRAVITY * (BALLDENSITY) ;
        totalFoces.y += ballForce[0].y*0.02*30; //Cada particula tem 0.02 de massa
        totalFoces.x += ballForce[0].x /(ballForce[0].y/2); //Divide por .y para fazer a media. Pois no X tem a soma das velocidades do X, e no y tem o numero de particulas
        totalFoces.z += ballForce[0].z /(ballForce[0].y/2); //Este /2 aparece como um fator de escala para por o movimento da bola mais relevante

        vec4 acc = totalFoces/BALLDENSITY;
        debug[0]=vec4(ballForce[0].x/ballForce[0].y,ballForce[0].y,ballForce[0].z/ballForce[0].y,ballForce[0].y*0.02*30);
        debug[1]=vec4(totalFoces);
        debug[2]=vec4(GRAVITY * (BALLDENSITY));
        debug[3]=vec4(acc);

        ballPos[0] += acc * TIMESTEP;

        ballForce[0] = ivec4(0);

        //manter dentro da caixa
        if (ballPos[0].y-BALLR < YMIN)
            ballPos[0].y=YMIN+BALLR;

        if (ballPos[0].x-BALLR < XMIN)
            ballPos[0].x=XMIN+BALLR;

        if (ballPos[0].z -BALLR < ZMIN)
            ballPos[0].z=ZMIN+BALLR;

        if (ballPos[0].x+BALLR > XMAX)
            ballPos[0].x=XMAX-BALLR;

        if (ballPos[0].z+BALLR > ZMAX)
            ballPos[0].z=ZMAX-BALLR;
    }
    
    uint offsetx = 47;
    uint offsety = 43;
    uint offsetz = 63;

    uint morton_x = uint((position[index].x / H) +offsetx);
    uint morton_y = uint((position[index].y / H) +offsety);
    uint morton_z = uint((position[index].z / H) +offsetz);
    uint morton_cell = interleave3(morton_x, morton_y, morton_z);

    bufferIndex[index] = morton_cell;
    tempIndex[index] = morton_cell;

    

    

    

}