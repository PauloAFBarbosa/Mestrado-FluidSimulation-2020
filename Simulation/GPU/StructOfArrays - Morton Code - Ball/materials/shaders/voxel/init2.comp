#version 430


#define WORK_GROUP_SIZE_X 32
#define WORK_GROUP_SIZE_Y 32
#define WORK_GROUP_SIZE_Z 1

layout (local_size_x = 32,local_size_y = 1) in;


layout(std430, binding = 1) buffer Position
{
    vec4 ParticlePos[];
};
layout(std430, binding = 4) buffer Velocity
{
    vec4 Vel[];
};

layout(rg16ui,binding = 3) uniform uimage3D voxelRep;
layout(rg16ui,binding = 2) uniform uimage3D voxelRepAux;

uniform int voxDim;


#ifndef NOISE
    #define NOISE
    #ifndef FNC_MOD289
    #define FNC_MOD289
    float mod289(in float x) {
      return x - floor(x * (1. / 289.)) * 289.;
    }

    vec2 mod289(in vec2 x) {
      return x - floor(x * (1. / 289.)) * 289.;
    }

    vec3 mod289(in vec3 x) {
      return x - floor(x * (1. / 289.)) * 289.;
    }

    vec4 mod289(in vec4 x) {
      return x - floor(x * (1. / 289.)) * 289.;
    }
    #endif
    #ifndef FNC_PERMUTE
    #define FNC_PERMUTE
    float permute(in float x) {
         return mod289(((x * 34.) + 1.)*x);
    }

    vec3 permute(in vec3 x) {
      return mod289(((x*34.0)+1.0)*x);
    }

    vec4 permute(in vec4 x) {
         return mod289(((x * 34.) + 1.)*x);
    }
    #endif
    #ifndef FNC_TAYLORINVSQRT
    #define FNC_TAYLORINVSQRT
    float taylorInvSqrt(in float r) {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec4 taylorInvSqrt(in vec4 r) {
      return 1.79284291400159 - 0.85373472095314 * r;
    }
    #endif
    #ifndef FNC_FADE
    #define FNC_FADE
    float fade(in float t) {
      return t * t * t * (t * (t * 6. - 15.) + 10.);
    }

    vec2 fade(in vec2 t) {
      return t * t * t * (t * (t * 6. - 15.) + 10.);
    }

    vec3 fade(in vec3 t) {
      return t * t * t * (t * (t * 6. - 15. ) + 10.);
    }

    vec4 fade(vec4 t) {
      return t*t*t*(t*(t*6.0-15.0)+10.0);
    }
    #endif
    float pnoise(in vec2 P, in vec2 rep) {
        vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
        vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
        Pi = mod(Pi, rep.xyxy); // To create noise with explicit period
        Pi = mod289(Pi);        // To avoid truncation effects in permutation
        vec4 ix = Pi.xzxz;
        vec4 iy = Pi.yyww;
        vec4 fx = Pf.xzxz;
        vec4 fy = Pf.yyww;

        vec4 i = permute(permute(ix) + iy);

        vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
        vec4 gy = abs(gx) - 0.5 ;
        vec4 tx = floor(gx + 0.5);
        gx = gx - tx;

        vec2 g00 = vec2(gx.x,gy.x);
        vec2 g10 = vec2(gx.y,gy.y);
        vec2 g01 = vec2(gx.z,gy.z);
        vec2 g11 = vec2(gx.w,gy.w);

        vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
        g00 *= norm.x;
        g01 *= norm.y;
        g10 *= norm.z;
        g11 *= norm.w;

        float n00 = dot(g00, vec2(fx.x, fy.x));
        float n10 = dot(g10, vec2(fx.y, fy.y));
        float n01 = dot(g01, vec2(fx.z, fy.z));
        float n11 = dot(g11, vec2(fx.w, fy.w));

        vec2 fade_xy = fade(Pf.xy);
        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
        float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
        return 2.3 * n_xy;
    }
#endif

uniform vec3 voxdimvec;
uniform vec3 simmin;
uniform vec3 simmax;
uniform vec3 voxmin;
uniform vec3 voxmax;

uniform float particleradius;

void main(){    
    vec3 fpos = ParticlePos[gl_GlobalInvocationID.x].xyz; 
    fpos = (fpos - voxmin) / (voxmax-voxmin);
    fpos *= voxdimvec;
    
    ivec3 pos = ivec3(fpos.xyz);

    vec3 worldposcenter = (voxmax-voxmin)*(pos/voxdimvec) + voxmin ;
    
    float particlerad = particleradius;
    ivec3 side = ivec3(ceil(voxdimvec*(particlerad/(voxmax-voxmin))));
    //ivec3 side = ivec3(2);
    for(int i = -side.x; i <= side.x; i++){
       for(int j = -side.y; j <= side.y; j++){
            for(int k = -side.z; k <= side.z; k++){

                vec3 worldpos = (voxmax-voxmin)*((pos+ivec3(i,j,k))/voxdimvec) + voxmin ;
                
                float dit = distance(worldpos,worldposcenter);
                if(dit <= particlerad){
                        if( length(Vel[gl_GlobalInvocationID.x])+0.5*(pnoise(worldpos.xy/20.0,vec2(10.0))) > 2.0)
                            imageAtomicAdd(voxelRepAux, pos+ivec3(i,j,k), imageLoad(voxelRepAux, pos+ivec3(i,j,k))+vec4((particlerad-dit)/(particlerad),0.1,1.0,1.0) );
                        else
                            imageAtomicAdd(voxelRepAux, pos+ivec3(i,j,k), imageLoad(voxelRepAux, pos+ivec3(i,j,k))+vec4((particlerad-dit)/(particlerad),0.0,1.0,1.0) );
                }
                memoryBarrier();
            }
        } 
    }
}
