#version 460

#define WORK_GROUP_SIZE 25

layout (local_size_x = WORK_GROUP_SIZE) in;

#define PARTICLE_RADIUS 0.005f

uniform int Number_Particles;
uniform mat4 m_model;

uniform float MASS;
uniform float RESTDENSITY;
uniform int HASHSIZE;
uniform int PONTOS_LADO;
uniform float H;

struct MyParticle
{
    vec4 position;
    vec4 velocity;
    vec4 Force;
    vec4 acceleration;
    vec4 gravity;
    vec4 SurfaceNormal;
    vec4 SurfaceTension;
    vec4 viscosity;
    float density;
    float pressure;
    float pad1;
    float pad2;
};

layout(std430, binding = 0) buffer Particle
{
    MyParticle particles[];
};

layout(std430, binding = 1) buffer ParticleTemp
{
    MyParticle tempParticles[];
};


layout(std430, binding = 2) buffer BucketSizes
{
    int bucketSizes[];
};

layout(std430, binding = 3) buffer Offsets
{
    int offsets[];
};



layout(std430, binding = 4) buffer TempBucketSizes
{
    int tempBucketSizes[];
};

layout(std430, binding = 5) buffer Position
{
    vec4 position[];
};


float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

uint hashFunction(vec4 pos,double H,int size) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;

    int part1 = (int((pos.x / H)) * p1);
    int part2 = (int((pos.y / H)) * p2);
    int part3 = (int ((pos.z / H)) * p3);
    
    uint ret = uint((part1 ^ part2 ^ part3) % size);
    
    return ret;
}

void main()
{
    
    
    uint index = gl_GlobalInvocationID.x;

    if (index > Number_Particles)
        return;

    //Agora vai correr todas as particulas de novo e vai adicionar ao hashmap
    // e no final vai hazer o compute dos offsets
    

    uint bucket = hashFunction(tempParticles[index].position, H, HASHSIZE);
    int bucketSize= atomicAdd(bucketSizes[bucket],1);
    int offset = 0;
    //vai correr o array com os tamanhos dos buckets até chegar ao bucket atual
    for (int j = 0; j < bucket; j++)
    {
        //exemplo, se tivermos um array com [p1,p2,p3,p4]
        //p1 e p2 sao do bucket 0 e p3 e p4 do bucket 1
        //o bucket 1 começa no indice 2 que é o bucketsize do bucket 0
        offset += tempBucketSizes[j];
    }

    particles[offset+bucketSize].position = tempParticles[index].position;
    particles[offset+bucketSize].velocity = tempParticles[index].velocity;
    
    position[index]= tempParticles[index].position;

    


}