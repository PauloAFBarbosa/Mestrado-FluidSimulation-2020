// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

#define WORK_GROUP_SIZE 32

layout (local_size_x = WORK_GROUP_SIZE) in;

// constants

#define TIME_STEP 0.0001f
#define WALL_DAMPING 0.3f
#define WALL_SIZEX 0.5
#define WALL_SIZEZ 0.5

uniform int Number_Particles;
uniform int Pause;
uniform float time;
uniform float XMAX;
uniform float YMAX;
uniform float ZMAX;

uniform float XMIN;
uniform float YMIN;
uniform float ZMIN;

uniform float DECLIVE;
uniform float RESTITUTION;
uniform float TIMESTEP;

struct MyParticle
{
    vec4 position;
    vec4 velocity;
    vec4 force;
    vec4 acceleration;
    vec4 gravity;
    vec4 surfaceNormal;
    vec4 surfaceTension;
    vec4 viscosity;
    float density;
    float pressure;
    float pad1;
    float pad2;
};

layout(std430, binding = 0) buffer Particle
{
    MyParticle particles[];
};

layout(std430, binding = 1) buffer BucketSizes
{
    int bucketSizes[];
};

layout(std430, binding = 2) buffer Offsets
{
    int offsets[];
};




bool detectCollision(vec4 pos, out vec4 contactPoint, out vec4 unitSurfaceNormal) {
    //o cubo esta centrado em 0,0,0
    float newx = pos.x + XMAX;
    float temp = (XMAX + XMAX) - newx;
    temp = temp / (XMAX + XMAX); //devolve 1 quando newx Ã© 0, ou seja, a particula esta encostada a parede esquerda
                                // devolve 0 quando esta encostada a parede direita

    float newy = YMIN + (temp * DECLIVE);

    if (pos.x <= XMAX && pos.x >= XMIN && pos.y <= YMAX && pos.y >= newy && pos.z <= ZMAX && pos.z >= ZMIN)
        return false;

    int maxComponent = 0;
    float maxValue = abs(pos.x);
    //Por causa do declive temos de ter isso em conta ao encontrar o maxvalue. (se nao fizer + temp*declive as vezes da como max component o Z quando na realidade deveria ter sido o Y, so nao foi por causa do declive)
    if (maxValue < abs(pos.y)+(temp*DECLIVE)) {
        maxComponent = 1;
        maxValue = abs(pos.y) + (temp * DECLIVE);
    }
    if (maxValue < abs(pos.z)) {
        maxComponent = 2;
        maxValue = abs(pos.z);
    }
    // 'unitSurfaceNormal' is based on the current position component with the largest absolute value
    
    switch (maxComponent) {
    case 0:
        if (pos.x < XMIN) {
            contactPoint = vec4(XMIN,pos.y,pos.z,0) ;
            
            if (pos.y < newy)     contactPoint.y = newy;
            else if (pos.y > YMAX) contactPoint.y = YMAX;
            if (pos.z < ZMIN)     contactPoint.z = ZMIN;
            else if (pos.z > ZMAX) contactPoint.z = ZMAX;
            
            unitSurfaceNormal = vec4(1,0,0,0);
            
            
        }
        else if (pos.x > XMAX) {
            contactPoint = vec4 (XMAX,pos.y,pos.z,0);

            if (pos.y < newy)     contactPoint.y = newy;
            else if (pos.y > YMAX) contactPoint.y = YMAX;
            if (pos.z < ZMIN)     contactPoint.z = ZMIN;
            else if (pos.z > ZMAX) contactPoint.z = ZMAX;
            
            unitSurfaceNormal = vec4(-1,0,0,0);
            

        }
        break;
    case 1:
        if (pos.y < newy) {
            contactPoint = vec4(pos.x,newy,pos.z,0);

            if (pos.x < XMIN)     contactPoint.x = XMIN;
            else if (pos.x > XMAX) contactPoint.x = XMAX;
            if (pos.z < ZMIN)     contactPoint.z = ZMIN;
            else if (pos.z > ZMAX) contactPoint.z = ZMAX;

            unitSurfaceNormal = vec4(DECLIVE,1-DECLIVE,0,0);
            
        }
        else if (pos.y > YMAX) {
            contactPoint = vec4(pos.x,YMAX,pos.z,0);

            if (pos.x < XMIN)     contactPoint.x = XMIN;
            else if (pos.x > XMAX) contactPoint.x = XMAX;
            if (pos.z < ZMIN)     contactPoint.z = ZMIN;
            else if (pos.z > ZMAX) contactPoint.z = ZMAX;

            unitSurfaceNormal = vec4(0,-1,0,0);
            
        }
        break;
    case 2:
        if (pos.z < ZMIN) {

            contactPoint=vec4(pos.x,pos.y,ZMIN,0);

            if (pos.x < XMIN)     contactPoint.x = XMIN;
            else if (pos.x > XMAX) contactPoint.x = XMAX;
            if (pos.y < newy)     contactPoint.y = newy;
            else if (pos.y > YMAX) contactPoint.y = YMAX;
            unitSurfaceNormal = vec4(0,0,1,0);
            
            
        }
        else if (pos.z > ZMAX) {
            contactPoint = vec4(pos.x,pos.y,ZMAX,0);

            if (pos.x < XMIN)     contactPoint.x = XMIN;
            else if (pos.x > XMAX) contactPoint.x = XMAX;
            if (pos.y < newy)     contactPoint.y = newy;
            else if (pos.y > YMAX) contactPoint.y = YMAX;
            unitSurfaceNormal = vec4(0,0,-1,0);
               
        }
        break;
    }

        
    return true;
}

void updateVelocity(vec4 velocity, vec4 unitSurfaceNormal, float penetrationDepth, out vec4 ret) {
    //ret = velocity - unitSurfaceNormal * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * glm::length(velocity))) * glm::dot(velocity, unitSurfaceNormal);
    
    ret= velocity - unitSurfaceNormal * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * length(velocity))) * dot(unitSurfaceNormal, velocity);
}

void main()
{
    if (Pause == 1)
        return;
    uint index = gl_GlobalInvocationID.x;

    if (index > Number_Particles)
        return;

    vec4 totalForce= vec4(0);

    totalForce = particles[index].force + particles[index].viscosity + particles[index].gravity + particles[index].surfaceTension;

    

    //employEulerIntegrator
    particles[index].acceleration = totalForce / particles[index].density;

    particles[index].velocity = particles[index].velocity + particles[index].acceleration * TIMESTEP;
    
    particles[index].position = particles[index].position + particles[index].velocity * TIMESTEP;

    vec4 contactPoint= vec4(0);
    vec4 unitSurfaceNormal= vec4(0);
    
    bool retcolision = detectCollision(particles[index].position, contactPoint, unitSurfaceNormal);
    


    if (retcolision) {
        
        vec4 ret;
        vec4 arg;
        
        arg = particles[index].position - contactPoint;

        updateVelocity(particles[index].velocity, unitSurfaceNormal, length(arg), ret);
        
        particles[index].velocity = ret;
        

        particles[index].position= contactPoint;
    }
}