// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

#define WORK_GROUP_SIZE 25

layout (local_size_x = WORK_GROUP_SIZE) in;

// constants

#define PI_FLOAT 3.1415927410125732421875f
#define PARTICLE_RADIUS 0.005f
#define PARTICLE_RESTING_DENSITY 4000
// Mass = Density * Volume
#define PARTICLE_MASS 0.02
#define SMOOTHING_LENGTH (4 * PARTICLE_RADIUS)

uniform float THRESHOLD;
uniform float SURFACETENSION;
uniform float VISCOSITY;
uniform int HASHSIZE;
uniform float MASS;
uniform vec4 GRAVITY;
uniform float H;
uniform int Number_Particles;
uniform vec3 External_Force;
uniform int Pause;

struct MyParticle
{
    vec4 position;
    vec4 velocity;
    vec4 force;
    vec4 acceleration;
    vec4 gravity;
    vec4 surfaceNormal;
    vec4 surfaceTension;
    vec4 viscosity;
    float density;
    float pressure;
    float pad1;
    float pad2;
};

layout(std430, binding = 0) buffer Particle
{
    MyParticle particles[];
};


layout(std430, binding = 1) buffer BucketSizes
{
    int bucketSizes[];
};

layout(std430, binding = 2) buffer Offsets
{
    int offsets[];
};

layout(std430, binding = 3) buffer AdjMat
{
    int adjMat[];
};

layout(std430, binding = 4) buffer Debug
{
    vec4 debug[];
};


void usePressureKernel_gradient(vec4 distVector, float supportRadius, out vec4 ret) {
    float dist = length(distVector);
    if (dist > supportRadius) {
        
        ret = vec4(0);
        
    }
    else
    {
        
        vec4 normalized;
        normalized=normalize(distVector);

        ret= -(normalized * (45 / (PI_FLOAT * pow(supportRadius, 6.0f))) * pow(supportRadius - dist, 2.0f));
        
    }
}

bool contains(uint arr[27], int size, uint member) {
    bool ret = false;

    for (int i = 0; i < size; i++)
    {
        if (arr[i] == member)
            ret = true;
    }
    return ret;
}

int getAdj(vec4 pos, float H, out uint ret[27]) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;
    int part1, part2, part3;
    int cell[3];
    cell[0] = int(pos.x / H);
    cell[1] = int(pos.y / H);
    cell[2] = int(pos.z / H);

    uint tempBucket;
    int retSize = 0;

    //bucket recebido
    part1 = int(cell[0] * p1);
    part2 = int(cell[1] * p2);
    part3 = int(cell[2] * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    ret[0] = tempBucket;
    
    retSize++;
    //bucket right
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    //tempPosition[0]=vec4(tempBucket);
    if (contains(ret,retSize,tempBucket)==false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //-----O mesmo mas para os buckets de cima
    //bucket recebido cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left cima
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front cima
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back cima 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }


    //-----O mesmo mas para os buckets de baixo
    //bucket recebido baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left baixo
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front baixo
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back baixo 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    

    return retSize;
    
}

float useViscosityKernel_laplacian(vec4 distVector, float supportRadius) {
    float dist = length(distVector);
    if (dist > supportRadius)
        return 0.0f;
    else
        return (45 / (PI_FLOAT * pow(supportRadius, 6.0f))) * (supportRadius - dist);
}

void useDefaultKernel_gradient(vec4 distVector, float supportRadius,out vec4 ret) {
    float dist = length(distVector);
    if (dist > supportRadius) {
        ret = vec4(0);
    }
    else {
        ret = -(distVector * (945 / (32 * PI_FLOAT * pow(supportRadius, 9.0f))) * pow(supportRadius * supportRadius - dist * dist, 2.0f));
    }
}

float useDefaultKernel_laplacian(vec4 distVector, float supportRadius) {
    float dist = length(distVector);
    if (dist > supportRadius)
        return 0.0f;
    else
        return -(945 / (32 * PI_FLOAT * pow(supportRadius, 9.0f))) * (supportRadius * supportRadius - dist * dist) * (3 * supportRadius * supportRadius - 7 * dist * dist);
}

uint hashFunction(vec4 pos,double H,int size) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;

    int part1 = (int((pos.x / H)) * p1);
    int part2 = (int((pos.y / H)) * p2);
    int part3 = (int ((pos.z / H)) * p3);
    
    uint ret = uint((part1 ^ part2 ^ part3) % size);
    
    return ret;
}

void main()
{
    if (Pause == 1)
        return;
    uint index = gl_GlobalInvocationID.x;
    if (index > Number_Particles)
        return;

    uint ret[27];
    int retSize=0;

    //uint b  = hashFunction(position[index],H,HASHSIZE);
    
    //retSize = adjMat[(28*b)+0] ; 

    retSize=getAdj(particles[index].position, H, ret);

    vec4 sumViscosity = vec4(0);
    vec4 sumForce = vec4(0);
    vec4 sumSurfaceNormal= vec4(0);
    float sum =0;

    
    int count;
    count=0;
    for (int j = 0; j < retSize; j++)
    {
        uint bucket = ret[j];
        //uint bucket = uint(adjMat[(28*b)+(j+1)]) ;

        //debug[index]= vec4(b,adjMat[(28*b)+(0)],adjMat[(28*b)+(1)],adjMat[(28*b)+(2)]);

        int offset = offsets[bucket];
        int bucketSize = bucketSizes[bucket];
        
        for (uint i = 0; i < bucketSize; i++)
        {
            if (particles[index].position.x == particles[offset+i].position.x && particles[index].position.y == particles[offset +i].position.y && particles[index].position.z == particles[offset + i].position.z)
                continue;

            
            //Viscosity
            vec4 arg;
            arg = particles[index].position - particles[offset+i].position;

            sumViscosity += (particles[offset+i].velocity - particles[index].velocity) * (MASS / particles[offset+i].density) * useViscosityKernel_laplacian(arg, H);

            //Force
            vec4 ret_kernel = vec4(0);
            arg = particles[index].position - particles[offset+i].position;
            
            usePressureKernel_gradient(arg, H, ret_kernel);
            
            sumForce += ret_kernel * (particles[index].pressure / (particles[index].density * particles[index].density) + particles[offset+i].pressure / (particles[offset+i].density * particles[offset+i].density)) * MASS;
            
            //SurfaceNormal
            vec4 ret2 = vec4(0);
            
            arg = particles[index].position - particles[offset+i].position;
            
            useDefaultKernel_gradient(arg, H, ret2);
            sumSurfaceNormal += ret2 * (MASS / particles[offset+i].density);
        }
    }

    
    particles[index].viscosity= sumViscosity * VISCOSITY;
    
    particles[index].force= -(sumForce*particles[index].density);

    //tempPosition[index]=vec4(sumForce[0],sumForce[1],sumForce[2 ],0);

    particles[index].surfaceNormal = sumSurfaceNormal;

    particles[index].gravity = GRAVITY * particles[index].density;

    if (length(particles[index].surfaceNormal) >= THRESHOLD) {
            
            
            uint ret[27];
            int retSize;
            //printf("vou mandar a posicao %f %f %f\n", position[0], position[1], position[2]);
            retSize = getAdj(particles[index].position, H, ret);
            for (int j = 0; j < retSize; j++)
            {
                uint bucket = ret[j];
                int offset = offsets[bucket];
                int bucketSize = bucketSizes[bucket];
                for (uint i = 0; i < bucketSize; i++)
                {
                    vec4 arg;
                    arg = particles[index].position - particles[offset+i].position;
                    sum += (MASS / particles[offset+i].density) * useDefaultKernel_laplacian(arg, H);
                }
            }

            vec4 surfaceNormalNormalized;

            surfaceNormalNormalized=normalize(particles[index].surfaceNormal);
            
            particles[index].surfaceTension= -(surfaceNormalNormalized * SURFACETENSION * sum);

        }
        else {
            particles[index].surfaceTension= vec4(0);
        }
}