#version 460

#define WORK_GROUP_SIZE 1

layout (local_size_x = WORK_GROUP_SIZE) in;

#define PARTICLE_RADIUS 0.005f

uniform int Number_Particles;
uniform mat4 m_model;

uniform float MASS;
uniform float RESTDENSITY;
uniform int HASHSIZE;
uniform int PONTOS_LADO;
uniform float H;

layout(std430, binding = 0) buffer Position
{
    vec4 position[];
};

layout(std430, binding = 1) buffer Velocity
{
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Force
{
    vec4 force[];
};

layout(std430, binding = 3) buffer Density
{
    float density[];
};

layout(std430, binding = 4) buffer Pressure
{
    float pressure[];
};

layout(std430, binding = 5) buffer Acceleration
{
    vec4 acceleration[];
};

layout(std430, binding = 6) buffer Gravity
{
    vec4 gravity[];
};

layout(std430, binding = 7) buffer SurfaceNormal
{
    vec4 surfaceNormal[];
};

layout(std430, binding = 8) buffer SurfaceTension
{
    vec4 surfaceTension[];
};

layout(std430, binding = 9) buffer Viscosity
{
    vec4 viscosity[];
};

layout(std430, binding = 10) buffer TempPosition
{
    vec4 tempPosition[];
};

layout(std430, binding = 11) buffer BucketSizes
{
    int bucketSizes[];
};

layout(std430, binding = 12) buffer Offsets
{
    int offsets[];
};

layout(std430, binding = 13) buffer TempVelocity
{
    vec4 tempvelocity[];
};



float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

uint hashFunction(vec4 pos,double H,int size) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;

    int part1 = (int((pos.x / H)) * p1);
    int part2 = (int((pos.y / H)) * p2);
    int part3 = (int ((pos.z / H)) * p3);
    
    uint ret = uint((part1 ^ part2 ^ part3) % size);
    
    return ret;
}

void main()
{
    
    int tempBucketSizes[1000];
    
    for (int i = 0; i < 1000; i++)
    {
        tempBucketSizes[i] = 0;
        bucketSizes[i] = 0;
    }
    

    for (int i = 0; i < Number_Particles; i++)
    {
        tempPosition[i] = position[i];
        
        uint newbucket =hashFunction(tempPosition[i], H,1000); 
        
        tempBucketSizes[newbucket]++;

        tempvelocity[i]= velocity[i];
        force[i]=vec4(0);
        density[i]=0.0;
        pressure[i]=0.0;
        acceleration[i]=vec4(0);
        gravity[i]=vec4(0);
        surfaceNormal[i]=vec4(0);
        surfaceTension[i]=vec4(0);
        viscosity[i]=vec4(0);
    }

    //Agora vai correr todas as particulas de novo e vai adicionar ao hashmap
    // e no final vai hazer o compute dos offsets
    for (int i =0 ; i < Number_Particles ; i ++)
    {

        uint bucket = hashFunction(tempPosition[i], H, 1000);
        int offset = 0;
        //vai correr o array com os tamanhos dos buckets até chegar ao bucket atual
        for (int j = 0; j < bucket; j++)
        {
            //exemplo, se tivermos um array com [p1,p2,p3,p4]
            //p1 e p2 sao do bucket 0 e p3 e p4 do bucket 1
            //o bucket 1 começa no indice 2 que é o bucketsize do bucket 0
            offset += tempBucketSizes[j];
        }

        position[offset+bucketSizes[bucket]] = tempPosition[i];
        velocity[offset+bucketSizes[bucket]] = tempvelocity[i];
        bucketSizes[bucket]++;

    }

    //Calcula os offsets
    offsets[0] = 0;

    for (int i = 1; i < HASHSIZE; i++)
    {
        offsets[i] = offsets[i - 1] + bucketSizes[i - 1];
    }


}