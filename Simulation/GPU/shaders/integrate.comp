// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

#define WORK_GROUP_SIZE 1

layout (local_size_x = WORK_GROUP_SIZE) in;

// constants

#define TIME_STEP 0.0001f
#define WALL_DAMPING 0.3f
#define WALL_SIZEX 0.5
#define WALL_SIZEZ 0.5

uniform int Number_Particles;
uniform int Pause;
uniform float time;
uniform float XMAX;
uniform float YMAX;
uniform float ZMAX;

uniform float XMIN;
uniform float YMIN;
uniform float ZMIN;

uniform float DECLIVE;
uniform float RESTITUTION;
uniform float TIMESTEP;

layout(std430, binding = 0) buffer Position
{
    vec4 position[];
};

layout(std430, binding = 1) buffer Velocity
{
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Force
{
    vec4 force[];
};

layout(std430, binding = 3) buffer Density
{
    float density[];
};

layout(std430, binding = 4) buffer Pressure
{
    float pressure[];
};

layout(std430, binding = 5) buffer Acceleration
{
    vec4 acceleration[];
};

layout(std430, binding = 6) buffer Gravity
{
    vec4 gravity[];
};

layout(std430, binding = 7) buffer SurfaceNormal
{
    vec4 surfaceNormal[];
};

layout(std430, binding = 8) buffer SurfaceTension
{
    vec4 surfaceTension[];
};

layout(std430, binding = 9) buffer Viscosity
{
    vec4 viscosity[];
};

layout(std430, binding = 10) buffer TempPosition
{
    vec4 tempPosition[];
};

layout(std430, binding = 11) buffer BucketSizes
{
    int bucketSizes[];
};

layout(std430, binding = 12) buffer Offsets
{
    int offsets[];
};

float length(float vec[3]) {
    return (sqrt(pow(vec[0],2)+ pow(vec[1], 2)+ pow(vec[2], 2)));
}

float lengthVec(vec4 vec) {
    return (sqrt(pow(vec.x,2)+ pow(vec.y, 2)+ pow(vec.z, 2)));
}
void normalize(float i[3], out float o[3]) {
    
    float len = length(i);
    o[0] = i[0] / len;
    o[1] = i[1] / len;
    o[2] = i[2] / len;
    
}

float dot(float v1[3], float v2[3]) {
    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

float dotVec(float v1[3], vec4 v2) {
    return v1[0] * v2.x + v1[1] * v2.y + v1[2] * v2.z;
}

bool detectCollision(vec4 pos, out float contactPoint[3], out float unitSurfaceNormal[3]) {
    //o cubo esta centrado em 0,0,0
    float newx = pos.x + XMAX;
    float temp = (XMAX + XMAX) - newx;
    temp = temp / (XMAX + XMAX); //devolve 1 quando newx Ã© 0, ou seja, a particula esta encostada a parede esquerda
                                // devolve 0 quando esta encostada a parede direita

    float newy = YMIN + (temp * DECLIVE);

    if (pos.x <= XMAX && pos.x >= XMIN && pos.y <= YMAX && pos.y >= newy && pos.z <= ZMAX && pos.z >= ZMIN)
        return false;

    int maxComponent = 0;
    float maxValue = abs(pos.x);
    //Por causa do declive temos de ter isso em conta ao encontrar o maxvalue. (se nao fizer + temp*declive as vezes da como max component o Z quando na realidade deveria ter sido o Y, so nao foi por causa do declive)
    if (maxValue < abs(pos.y)+(temp*DECLIVE)) {
        maxComponent = 1;
        maxValue = abs(pos.y) + (temp * DECLIVE);
    }
    if (maxValue < abs(pos.z)) {
        maxComponent = 2;
        maxValue = abs(pos.z);
    }
    // 'unitSurfaceNormal' is based on the current position component with the largest absolute value
    
    switch (maxComponent) {
    case 0:
        if (pos.x < XMIN) {
            contactPoint[0] = XMIN;
            contactPoint[1] = pos.y; 
            contactPoint[2] = pos.z;

            if (pos.y < newy)     contactPoint[1] = newy;
            else if (pos.y > YMAX) contactPoint[1] = YMAX;
            if (pos.z < ZMIN)     contactPoint[2] = ZMIN;
            else if (pos.z > ZMAX) contactPoint[2] = ZMAX;
            
            unitSurfaceNormal[0] = 1;
            unitSurfaceNormal[1] = 0;
            unitSurfaceNormal[2] = 0;
            
        }
        else if (pos.x > XMAX) {
            contactPoint[0] = XMAX;
            contactPoint[1] = pos.y;
            contactPoint[2] = pos.z;

            if (pos.y < newy)     contactPoint[1] = newy;
            else if (pos.y > YMAX) contactPoint[1] = YMAX;
            if (pos.z < ZMIN)     contactPoint[2] = ZMIN;
            else if (pos.z > ZMAX) contactPoint[2] = ZMAX;
            
            unitSurfaceNormal[0] = -1;
            unitSurfaceNormal[1] = 0;
            unitSurfaceNormal[2] = 0;
            

        }
        break;
    case 1:
        if (pos.y < newy) {
            contactPoint[0] = pos.x;
            contactPoint[1] = newy;
            contactPoint[2] = pos.z;

            if (pos.x < XMIN)     contactPoint[0] = XMIN;
            else if (pos.x > XMAX) contactPoint[0] = XMAX;
            if (pos.z < ZMIN)     contactPoint[2] = ZMIN;
            else if (pos.z > ZMAX) contactPoint[2] = ZMAX;

            unitSurfaceNormal[0] = DECLIVE;
            unitSurfaceNormal[1] = 1-DECLIVE;
            unitSurfaceNormal[2] = 0;
            
        }
        else if (pos.y > YMAX) {
            contactPoint[0] = pos.x;
            contactPoint[1] = YMAX;
            contactPoint[2] = pos.z;

            if (pos.x < XMIN)     contactPoint[0] = XMIN;
            else if (pos.x > XMAX) contactPoint[0] = XMAX;
            if (pos.z < ZMIN)     contactPoint[2] = ZMIN;
            else if (pos.z > ZMAX) contactPoint[2] = ZMAX;

            unitSurfaceNormal[0] = 0;
            unitSurfaceNormal[1] = -1;
            unitSurfaceNormal[2] = 0;
            
        }
        break;
    case 2:
        if (pos.z < ZMIN) {
            contactPoint[0] = pos.x;
            contactPoint[1] = pos.y;
            contactPoint[2] = ZMIN;

            if (pos.x < XMIN)     contactPoint[0] = XMIN;
            else if (pos.x > XMAX) contactPoint[0] = XMAX;
            if (pos.y < newy)     contactPoint[1] = newy;
            else if (pos.y > YMAX) contactPoint[1] = YMAX;
            unitSurfaceNormal[0] = 0;
            unitSurfaceNormal[1] = 0;
            unitSurfaceNormal[2] = 1;
            
        }
        else if (pos.z > ZMAX) {
            contactPoint[0] = pos.x;
            contactPoint[1] = pos.y;
            contactPoint[2] = ZMAX;

            if (pos.x < XMIN)     contactPoint[0] = XMIN;
            else if (pos.x > XMAX) contactPoint[0] = XMAX;
            if (pos.y < newy)     contactPoint[1] = newy;
            else if (pos.y > YMAX) contactPoint[1] = YMAX;
            unitSurfaceNormal[0] = 0;
            unitSurfaceNormal[1] = 0;
            unitSurfaceNormal[2] = -1;
            
        }
        break;
    }

        
    return true;
}

void updateVelocity(vec4 velocity, float unitSurfaceNormal[3], float penetrationDepth, out float ret[3]) {
    //ret = velocity - unitSurfaceNormal * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * glm::length(velocity))) * glm::dot(velocity, unitSurfaceNormal);
    
    ret[0] = velocity.x - unitSurfaceNormal[0] * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * lengthVec(velocity))) * dotVec(unitSurfaceNormal, velocity);
    ret[1] = velocity.y - unitSurfaceNormal[1] * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * lengthVec(velocity))) * dotVec(unitSurfaceNormal, velocity);
    ret[2] = velocity.z - unitSurfaceNormal[2] * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * lengthVec(velocity))) * dotVec(unitSurfaceNormal, velocity);
}

void main()
{
    if (Pause == 1)
        return;
    uint index = gl_GlobalInvocationID.x;

    float totalForce[3] = { 0,0,0 };

    totalForce[0] = force[index].x + viscosity[index].x + gravity[index].x + surfaceTension[index].x;
    totalForce[1] = force[index].y + viscosity[index].y + gravity[index].y + surfaceTension[index].y;
    totalForce[2] = force[index].z + viscosity[index].z + gravity[index].z + surfaceTension[index].z;

    

    //employEulerIntegrator
    acceleration[index].x = totalForce[0] / density[index];
    acceleration[index].y = totalForce[1] / density[index];
    acceleration[index].z = totalForce[2] / density[index];

    velocity[index].x = velocity[index].x + acceleration[index].x * TIMESTEP;
    velocity[index].y = velocity[index].y + acceleration[index].y * TIMESTEP;
    velocity[index].z = velocity[index].z + acceleration[index].z * TIMESTEP;
    


    position[index].x = position[index].x + velocity[index].x * TIMESTEP;
    position[index].y = position[index].y + velocity[index].y * TIMESTEP;
    position[index].z = position[index].z + velocity[index].z * TIMESTEP;

    float contactPoint[3] = { 0,0,0 };
    float unitSurfaceNormal[3] = { 0,0,0 };
    
    bool retcolision = detectCollision(position[index], contactPoint, unitSurfaceNormal);
    


    if (retcolision) {
        
        float ret[3] = { 0,0,0 };
        float arg[3];
        
        arg[0] = position[index].x - contactPoint[0];
        arg[1] = position[index].y - contactPoint[1];
        arg[2] = position[index].z - contactPoint[2];

        updateVelocity(velocity[index], unitSurfaceNormal, length(arg), ret);
        
        velocity[index].x = ret[0];
        velocity[index].y = ret[1];
        velocity[index].z = ret[2];
        

        position[index].x = contactPoint[0];
        position[index].y = contactPoint[1];
        position[index].z = contactPoint[2];
    }
}