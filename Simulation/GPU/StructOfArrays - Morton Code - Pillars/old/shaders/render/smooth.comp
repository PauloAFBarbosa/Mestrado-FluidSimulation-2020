#version 430

uniform sampler2D depthMap;
uniform sampler2D thickness;


#define WORKGROUPSIZE 32
layout (local_size_x = 1024, local_size_y = 1) in;

uniform int Blur;
uniform float Blur_Size;
uniform float Blur_Quality;
uniform vec2 resolution;

layout(binding=0, rgba32f) volatile uniform image2D imageUnit;
layout(binding=1, rgba32f) volatile uniform image2D imageAux;

/*

vec3 centreColour = texture2D(image,texCoord);
vec3 result = centreColour;
float normalization = 1;
for (int i = 0; i < NUM_SAMPLES; ++1)
{
   vec3 sample = texture2D(image, texCoord + offsets[i]);
   float gaussianCoeff = computeGaussianCoeff(offsets[i]);

   //depends on your implementation, this is quick
   float closeness = 1.0f - distance(sample,centreColour) / length(vec3(1,1,1));

   float sampleWeight = closeness * gaussian;

   result += sample * sampleWeight;
   noralization += sampleWeight;
}
vec3 bilateral = result / normalization;

*/

#define EPS 1e-5

float lum(in vec4 color) {
    return length(color.xyz);
}

uniform float BILAT_S;
uniform float BILAT_L;


vec4 bilateral(ivec2 uv){

  float sigmaS = BILAT_S;
  float sigmaL = BILAT_L;

  float sigS = max(sigmaS, EPS);
  float sigL = max(sigmaL, EPS);

  float facS = -1./(2.*sigS*sigS);
  float facL = -1./(2.*sigL*sigL);

  float sumW = 0.;
  vec4  sumC = vec4(0.);
  float halfSize = sigS * 2;
  ivec2 textureSize2 = imageSize(imageUnit);

  float l = lum(imageLoad(imageUnit,uv));

  for (float i = -halfSize; i <= halfSize; i ++){
    for (float j = -halfSize; j <= halfSize; j ++){
      ivec2 pos = ivec2(i, j);
      vec4 offsetColor = imageLoad(imageUnit, uv+pos);

      float distS = length(pos);
      float distL = lum(offsetColor)-l;

      float wS = exp(facS*float(distS*distS));
      float wL = exp(facL*float(distL*distL));
      float w = wS*wL;

      sumW += w;
      sumC += offsetColor * w;
    }
  }
  return sumC/sumW;
}

vec4 bilateral2(ivec2 uv){

  float sigmaS = BILAT_S;
  float sigmaL = BILAT_L;

  float sigS = max(sigmaS, EPS);
  float sigL = max(sigmaL, EPS);

  float facS = -1./(2.*sigS*sigS);
  float facL = -1./(2.*sigL*sigL);

  float sumW = 0.;
  vec4  sumC = vec4(0.);
  float halfSize = sigS * 2;
  ivec2 textureSize2 = imageSize(imageAux);

  float l = lum(imageLoad(imageAux,uv));

  for (float i = -halfSize; i <= halfSize; i ++){
    for (float j = -halfSize; j <= halfSize; j ++){
      ivec2 pos = ivec2(i, j);
      vec4 offsetColor = imageLoad(imageAux, uv+pos);

      float distS = length(pos);
      float distL = lum(offsetColor)-l;

      float wS = exp(facS*float(distS*distS));
      float wL = exp(facL*float(distL*distL));
      float w = wS*wL;

      sumW += w;
      sumC += offsetColor * w;
    }
  }
  return sumC/sumW;
}


void main(){
	ivec2 texCoord = ivec2(gl_GlobalInvocationID);
  int i = 0;

    for(int i = 0;i < 1024; i+=1024)
      for(int j = 0;j < 576; j+=1)
      {
        imageStore(imageUnit,texCoord+ivec2(i,j),  texelFetch(depthMap, texCoord+ivec2(i,j), 0));
      }
    
  memoryBarrierImage();
    /*
    BLUR to image x
    */
	vec4 tl = texelFetchOffset(depthMap, texCoord, 0, ivec2(-1, -1));

  for(int iter=0;iter < 3;iter++){
    for(int i = 0;i < 1024; i+=1024)
      for(int j = 0;j < 576; j+=1)
      {
	      vec4 res =  bilateral(texCoord+ivec2(i,j)) ;

	      imageStore(imageAux, texCoord +ivec2(i,j), res);
      }

    memoryBarrierImage();

    for(int i = 0;i < 1024; i+=1024)
      for(int j = 0;j < 576; j+=1)
      {
        vec4 res =  imageLoad(imageAux, texCoord+ivec2(i,j))  ;
  
	      imageStore(imageUnit, texCoord +ivec2(i,j), res);
      }
    memoryBarrierImage();
  }

}