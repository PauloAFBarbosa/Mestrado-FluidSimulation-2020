#version 460

#define WORK_GROUP_SIZE 1

layout (local_size_x = WORK_GROUP_SIZE) in;

#define PARTICLE_RADIUS 0.005f


uniform int Number_Particles;
uniform mat4 m_model;

uniform float MASS;
uniform float RESTDENSITY;
uniform int HASHSIZE;
uniform int PONTOS_LADO;
uniform float H;


layout(std430, binding = 0) buffer Position
{
    vec4 position[];
};

layout(std430, binding = 1) buffer TempPosition
{
    vec4 tempPosition[];
};

layout(std430, binding = 2) buffer Index
{
    uint radixIndex[];
};

layout(std430, binding = 3) buffer CountRadix
{
    uint countRadix[];
};

layout(std430, binding = 4) buffer TempIndex
{
    uint tempIndex[];
};

layout(std430, binding = 5) buffer UseTemp
{
    uint useTemp[];
};

void main()
{
    
    
    uint index = gl_GlobalInvocationID.x;
    
    uint max =0;
    if (index > Number_Particles)
        return;

    for(int i =0 ; i < Number_Particles ; i ++)
    {
        if(useTemp[0]==0){
            if (radixIndex[i]>max)
                max =radixIndex[i];
        }
        else{
            if (tempIndex[i]>max)
                max =tempIndex[i];
        }
        
    }

    for (int exp = 1; max / exp > 0; exp *= 10){
        
        for (int j = 0; j < 10; j++) {
            countRadix[j] = 0;
        }
            

        for (int j = 0; j < Number_Particles; j++) {
            if(useTemp[0]==0){
                countRadix[ (radixIndex[j]/exp) %10 ]++;
            }
            else{
                countRadix[ (tempIndex[j]/exp) %10 ]++;
            }
            
            //countRadix[unsigned int(radixIndex[j]/pow(10, shift))%10]++;
            //printf("%d vai incrementar\n ", (radixIndex[j] / exp) % 10);
        }

        for (int j = 1; j < 10; j++)
            countRadix[j] += countRadix[j - 1];

        for (int j = Number_Particles - 1; j >= 0; j--) {

            if(useTemp[0]==0){
                uint idx = (radixIndex[j] / exp) % 10;
            
                uint original = countRadix[idx] - 1;

                tempIndex[original] = radixIndex[j];
                tempPosition[original] = position[j];
                
                
                countRadix[idx]= original;    
                
            }
            else{
                uint idx = (tempIndex[j] / exp) % 10;
            
                uint original = countRadix[idx] - 1;

                radixIndex[original] = tempIndex[j];
                position[original] = tempPosition[j];
                countRadix[idx]= original;
                
            }

            
        }
         if(useTemp[0]==0){
            useTemp[0]=1;
        }
        else{
            useTemp[0]=0;
        }
        
    }
    
    

}