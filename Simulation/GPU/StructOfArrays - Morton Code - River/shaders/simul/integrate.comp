// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

#define WORK_GROUP_SIZE 32

layout (local_size_x = WORK_GROUP_SIZE) in;

// constants

#define TIME_STEP 0.0001f

#define WALL_SIZEX 0.5
#define WALL_SIZEZ 0.5

uniform int Number_Particles;
uniform int Pause;
uniform float WALL_DAMPING;
uniform float time;
uniform float XMAX;
uniform float YMAX;
uniform float ZMAX;

uniform float XMIN;
uniform float YMIN;
uniform float ZMIN;


uniform float RESTITUTION;
uniform float TIMESTEP;
uniform vec4 GRAVITY;

uniform vec4 Ball;
uniform float BallSize;
uniform int COLLISIONTYPE;
uniform int computeGravity;

uniform sampler2D river;

layout(std430, binding = 0) buffer Position
{
    vec4 position[];
};

layout(std430, binding = 1) buffer Velocity
{
    vec4 velocity[];
};

layout(std430, binding = 2) buffer Force
{
    vec4 force[];
};

layout(std430, binding = 3) buffer Density
{
    float density[];
};



layout(std430, binding = 4) buffer Acceleration
{
    vec4 acceleration[];
};

layout(std430, binding = 5) buffer Gravity
{
    vec4 gravity[];
};



layout(std430, binding = 6) buffer SurfaceTension
{
    vec4 surfaceTension[];
};

layout(std430, binding = 7) buffer Viscosity
{
    vec4 viscosity[];
};

layout(std430, binding = 8) buffer Debug
{
    vec4 debug[];
};

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

bool detectCollisionV2(in vec4 oldPos,in vec4 pos,in vec4 vel,in uint index,out int hitBall, out vec4 contactPoint, out vec4 unitSurfaceNormal,out vec4 retVelocity) {
    //o cubo esta centrado em 0,0,0
    float newx = pos.x + XMAX;
    float temp = (XMAX + XMAX) - newx;
    temp = temp / (XMAX + XMAX); //devolve 1 quando newx é 0, ou seja, a particula esta encostada a parede esquerda
                                // devolve 0 quando esta encostada a parede direita

    vec2 textPos = vec2(map(pos.x,XMIN,XMAX,0.2,0.99),map(pos.z,ZMIN,ZMAX,0.01,0.99));
    
    texture(river, textPos);

    float newy = YMIN + pow(texture(river, textPos).x,2);

    if (pos.x <= XMAX && pos.x >= XMIN && pos.y <= YMAX && pos.y >= newy && pos.z <= ZMAX && pos.z >= ZMIN){
        
        //Colission with the ball
        float dist=length(Ball-pos);
        
        if(dist<BallSize){
            vec4 pointer=normalize(pos-Ball);
            contactPoint = Ball + pointer*BallSize;
            unitSurfaceNormal=pointer;
            //Como o contact point agora pode estar fora no volume tenho de verificar isso

            if (contactPoint.x < XMIN) {
                    contactPoint.x = XMIN;
            }
            else if (contactPoint.x > XMAX) {
                    contactPoint.x = XMAX;
            }
            if (contactPoint.y < newy) {
                    contactPoint.y =newy;
                }
                else if (contactPoint.y > YMAX) {
                    contactPoint.y =YMAX;
                }
                
            
                if (contactPoint.z < ZMIN) {
                    contactPoint.z =ZMIN;                    
                }
                else if (contactPoint.z > ZMAX) {
                    contactPoint.z =ZMAX;                       
                }

            float penetrationDepth = length(pos - contactPoint);
        if (COLLISIONTYPE == 0){
            retVelocity= vel-(2) * dot(unitSurfaceNormal, (vel))*unitSurfaceNormal;
            retVelocity *=0.5;
        }
        else
            retVelocity= vel -  (1+RESTITUTION *(penetrationDepth/(TIMESTEP*length(vel)))) * dot(unitSurfaceNormal, vel)*unitSurfaceNormal;
            hitBall=1;
            return true;
        }
        else{
            contactPoint=pos;
            retVelocity=vel;
            hitBall=0;
            return false;
        }
    }


    contactPoint = pos;

    unitSurfaceNormal= vec4(0);

    int zx =0;
    retVelocity=vel;
    if (pos.x < XMIN) {
        zx=1;
            contactPoint.x = XMIN;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(1,0,0,0));
            

            
            
    }
    else if (pos.x > XMAX) {
        zx=1;
            contactPoint.x = XMAX;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(-1,0,0,0));
            

    }
    if (pos.y < newy) {
            contactPoint.y =newy;
            //compute normal
            float tstep =0.001;
            vec3 top =vec3(textPos.x,0,textPos.y+tstep);
            top.y = texture(river, vec2(textPos.x,textPos.y+tstep)).x;

            vec3 bot = vec3(textPos.x,0,textPos.y-tstep);
            bot.y= texture(river,vec2(textPos.x,textPos.y-tstep)).x;
            
            vec3 left = vec3(textPos.x-tstep,0,textPos.y); 
            left.y= texture(river,vec2(textPos.x-tstep,textPos.y)).x;
            
            vec3 right = vec3(textPos.x+tstep,0,textPos.y); 
            right.y= texture(river,vec2(textPos.x+tstep,textPos.y)).x;

            vec3 v1 = normalize(top-bot);
            vec3 v2 = normalize(left - right);

            vec3 result =normalize(cross(v2,v1));

            debug[index] = vec4(result.x,result.y,result.z,0);

            //unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(result.x,result.y,result.z,0));
            
            unitSurfaceNormal = vec4(result.x,result.y,result.z,0);
            
        }
        else if (pos.y > YMAX) {
            contactPoint.y =YMAX;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,-1,0,0));
            
            
        }
        
    
        if (pos.z < ZMIN) {
            zx=1;
            contactPoint.z =ZMIN;
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,0,1,0));
            
            
            
        }
        else if (pos.z > ZMAX) {
            zx=1;
            contactPoint.z =ZMAX;
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,0,-1,0));
            
             
        }

        float dist=length(Ball-pos);
        if(dist<BallSize){
            vec4 pointer=normalize(pos-Ball);
            //contactPoint = Ball + pointer*BallSize;
            unitSurfaceNormal=normalize(unitSurfaceNormal+pointer);
            
        }
        
        float penetrationDepth = length(pos - contactPoint);
        if (COLLISIONTYPE == 0)
            retVelocity= vel-(2) * dot(unitSurfaceNormal, (vel))*unitSurfaceNormal;
        else
            retVelocity= vel -  (1+RESTITUTION *(penetrationDepth/(TIMESTEP*length(vel)))) * dot(unitSurfaceNormal, vel)*unitSurfaceNormal;
        //retVelocity *= RESTITUTION;
        
        //
        
        //retVelocity=retVelocity*RESTITUTION;
        hitBall=0;
        
        return true;
}

bool detectCollisionV3(in vec4 oldPos,in vec4 pos,in vec4 vel,in uint index,out int hitBall, out vec4 contactPoint, out vec4 unitSurfaceNormal,out vec4 retVelocity) {
    //o cubo esta centrado em 0,0,0
    float newx = pos.x + XMAX;
    float temp = (XMAX + XMAX) - newx;
    temp = temp / (XMAX + XMAX); //devolve 1 quando newx é 0, ou seja, a particula esta encostada a parede esquerda
                                // devolve 0 quando esta encostada a parede direita

    vec2 textPos = vec2(map(pos.z,ZMIN,ZMAX,0.2,0.99),map(pos.x,XMIN,XMAX,0.01,0.99));
    

    float newy = YMIN + texture(river, textPos).x;

    contactPoint = pos;

    unitSurfaceNormal= vec4(0);

    int zx =0;
    retVelocity=vel;

    int collision =0;
    if (pos.x < XMIN) {
        zx=1;
        collision =1;
            contactPoint.x = XMIN;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(1,0,0,0));
            

            
            
    }
    else if (pos.x > XMAX) {
        zx=1;
        collision =1;
            contactPoint.x = XMAX;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(-1,0,0,0));
            

    }
    if (pos.y > YMAX) {
        collision =1;
            contactPoint.y =YMAX;
            
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,-1,0,0));
            
            
        }
        else if (pos.y < newy){
            contactPoint.y =newy;
            //compute normal
            float tstep =0.001;
            vec3 top =vec3(textPos.x,0,textPos.y+tstep);
            top.y = texture(river, vec2(textPos.x,textPos.y+tstep)).x;

            vec3 bot = vec3(textPos.x,0,textPos.y-tstep);
            bot.y= texture(river,vec2(textPos.x,textPos.y-tstep)).x;
            
            vec3 left = vec3(textPos.x-tstep,0,textPos.y); 
            left.y= texture(river,vec2(textPos.x-tstep,textPos.y)).x;
            
            vec3 right = vec3(textPos.x+tstep,0,textPos.y); 
            right.y= texture(river,vec2(textPos.x+tstep,textPos.y)).x;

            vec3 v1 = normalize(top-bot);
            vec3 v2 = normalize(left - right);

            vec3 result =normalize(cross(v2,v1));

            

            //unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(result.x,result.y,result.z,0));
            
            unitSurfaceNormal = vec4(result.x,result.y,result.z,0);
        }
        
    
        if (pos.z < ZMIN) {
            collision =1;
            zx=1;
            contactPoint.z =ZMIN;
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,0,1,0));
            
            
            
        }
        else if (pos.z > ZMAX) {
            collision =1;
            zx=1;
            contactPoint.z =ZMAX;
            unitSurfaceNormal = normalize(unitSurfaceNormal+vec4(0,0,-1,0));
            
             
        }

        
        float penetrationDepth = length(pos - contactPoint);
        if (COLLISIONTYPE == 0 && collision ==1)
            retVelocity= vel-(2) * dot(unitSurfaceNormal, (vel))*unitSurfaceNormal;
        else if (collision ==1)
            retVelocity= vel -  (1+RESTITUTION *(penetrationDepth/(TIMESTEP*length(vel)))) * dot(unitSurfaceNormal, vel)*unitSurfaceNormal;
        //retVelocity *= RESTITUTION;
        
        //
        
        //retVelocity=retVelocity*RESTITUTION;
        hitBall=0;
        
        return true;
}




void updateVelocity(vec4 velocity, vec4 unitSurfaceNormal, float penetrationDepth, out vec4 ret) {
    //ret = velocity - unitSurfaceNormal * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * glm::length(velocity))) * glm::dot(velocity, unitSurfaceNormal);
    
    ret= velocity -  (2) * dot(unitSurfaceNormal, normalize(velocity))*unitSurfaceNormal;
}

void updateVelocityV2(vec4 velocity, vec4 unitSurfaceNormal, float penetrationDepth, out vec4 ret) {
    //ret = velocity - unitSurfaceNormal * (1 + RESTITUTION * penetrationDepth / (TIMESTEP * glm::length(velocity))) * glm::dot(velocity, unitSurfaceNormal);
    
    ret= velocity -  (1+RESTITUTION *(penetrationDepth/(TIMESTEP*length(velocity)))) * dot(unitSurfaceNormal, normalize(velocity))*unitSurfaceNormal;
}



void main()
{
    if (Pause == 1)
        return;
    uint index = gl_GlobalInvocationID.x;

    if (index > Number_Particles)
        return;

    vec4 totalForce= vec4(0);

    //retirado surfaceTension
    // aqui se tiver GRAVITY * density cada particula vai ter uma gravidade diferente, e assim as de baixo sofrem mais gravidade (visto que tem mais gravidade)
    
    if (computeGravity==0)
        totalForce = force[index] + viscosity[index] + GRAVITY * 1000 + surfaceTension[index];
    else
        totalForce = force[index] + viscosity[index] + GRAVITY * density[index]+ surfaceTension[index];

    //Simple sample - 6 neighbours

    
    vec4 top = position[index];
    top.y += 0.04;

    vec4 bot = position[index];
    bot.y -=0.04;

    vec4 left = position[index];
    left.x -=0.04;

    vec4 right = position[index];
    right.x +=0.04;

    vec4 front = position[index];
    front.z -=0.04;

    vec4 back = position[index];
    back.z +=0.04;


    vec2 textPos = vec2(map(top.z,ZMIN,ZMAX,0.2,0.99),map(top.x,XMIN,XMAX,0.01,0.99));
    float newy = YMIN + texture(river, textPos).x;

    if (newy > top.y || newy > bot.y){
        //colisao top
        if(totalForce.y<0){
            totalForce.y=0;
            if(velocity[index].y < 0)
                velocity[index].y =0;
        }
    }

    textPos = vec2(map(left.z,ZMIN,ZMAX,0.2,0.99),map(left.x,XMIN,XMAX,0.01,0.99));
    newy = YMIN + texture(river, textPos).x;
    if(newy > left.y){
        //colisao left
        if(totalForce.x < 0){
            totalForce.x =0;
            if(velocity[index].x < 0)
                velocity[index].x=0;
        }
    }

    textPos = vec2(map(right.z,ZMIN,ZMAX,0.2,0.99),map(right.x,XMIN,XMAX,0.01,0.99));
    newy = YMIN + texture(river, textPos).x;
    if(newy > right.y){
        //colisao right
        if(totalForce.x > 0){
            totalForce.x =0;
            if(velocity[index].x > 0)
                velocity[index].x=0;
        }
    }

    textPos = vec2(map(front.z,ZMIN,ZMAX,0.2,0.99),map(front.x,XMIN,XMAX,0.01,0.99));
    newy = YMIN + texture(river, textPos).x;
    if(newy > front.y){
        //colisao front
        if(totalForce.z < 0){
            totalForce.z =0;
            if(velocity[index].z < 0)
                velocity[index].z=0;
        }
    }

    textPos = vec2(map(back.z,ZMIN,ZMAX,0.2,0.99),map(back.x,XMIN,XMAX,0.01,0.99));
    newy = YMIN + texture(river, textPos).x;
    if(newy > back.y){
        //colisao back
        if(totalForce.z > 0){
            totalForce.z =0;
            if(velocity[index].z > 0)
                velocity[index].z=0;
        }
    }
    

    //employEulerIntegrator
    vec4 acc= (totalForce / density[index]);

    vec4 oldPosition = position[index];
    /*
    if(oldPosition.y < (-1.9)){
        velocity[index].y=0;        
        acc.y=0;

    }

    if(oldPosition.x < (-2.07)){
        velocity[index].x=0;        
        acc.x=0;
    }

    if(oldPosition.x > (2.07)){
        velocity[index].x=0;        
        acc.x=0;
    }

    if(oldPosition.z < (-2.8)){
        velocity[index].z=0;        
        acc.z=0;
    }

    if(oldPosition.z > (2.8)){
        velocity[index].z=0;        
        acc.z=0;
    }
    */

    vec4 vel = velocity[index]+ acc * TIMESTEP;
    
    
    vec4 pos = oldPosition + vel * TIMESTEP;
    /*
    if(pos.y < (-1.9)){
        pos.y=-1.85;
    }

    if(pos.x < (-2.07)){
        pos.x=0;
    }

    if(pos.x > (2.07)){
        pos.x=0;
    }

    if(pos.z < (-2.8)){
        pos.z=0;
    }

    if(pos.z > (2.8)){
        pos.z=0;
    }
    */
    vec4 contactPoint= vec4(0);
    vec4 unitSurfaceNormal= vec4(0);
    vec4 retVolocity= vec4(0);
    //usado para saber se entrou em colisão com a bola, para aumentar o RESTITUTION
    int hitball=0;
    bool retcolision = detectCollisionV3(oldPosition,pos,vel,index,hitball, contactPoint, unitSurfaceNormal,retVolocity);


    position[index]=contactPoint;
    velocity[index]=retVolocity;

    
}