// Copyright (c) 2017-2018, Samuel Ivan Gunadi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460

#define WORK_GROUP_SIZE 32

layout (local_size_x = WORK_GROUP_SIZE) in;

// constants

#define PI_FLOAT 3.1415927410125732421875f
#define PARTICLE_RADIUS 0.005f
#define PARTICLE_RESTING_DENSITY 4000
#define UM_SOBRE_H 21.881838074398249452954048140044
// Mass = Density * Volume
#define PARTICLE_MASS 0.02
#define SMOOTHING_LENGTH (4 * PARTICLE_RADIUS)
#define MAXADJ 500

uniform float THRESHOLD;
uniform float SURFACETENSION;
uniform float VISCOSITY;
uniform int HASHSIZE;
uniform float MASS;
uniform vec4 GRAVITY;
uniform float H;
uniform int Number_Particles;
uniform vec3 External_Force;
uniform int Pause;
uniform float SIMULATIONSCALEFORCE;

uniform float XMAX;
uniform float YMAX;
uniform float ZMAX;

uniform float XMIN;
uniform float YMIN;
uniform float ZMIN;
uniform sampler2D river;

layout(std430, binding = 0) readonly restrict buffer Position
{
    vec4 position[];
};

layout(std430, binding = 1) readonly restrict buffer Velocity
{
    vec4 velocity[];
};

layout(std430, binding = 2) restrict buffer Force
{
    vec4 force[];
};

layout(std430, binding = 3) readonly restrict buffer Density
{
    float density[];
};

layout(std430, binding = 4) readonly restrict buffer Pressure
{
    
    float pressure[];
};



layout(std430, binding = 5) readonly restrict buffer Gravity
{
    vec4 gravity[];
};

layout(std430, binding = 6) restrict buffer SurfaceNormal
{
    vec4 surfaceNormal[];
};

layout(std430, binding = 7) restrict buffer SurfaceTension
{
    vec4 surfaceTension[];
};

layout(std430, binding = 8) restrict buffer Viscosity
{
    vec4 viscosity[];
};







layout(std430, binding = 9) restrict buffer Debug
{
    vec4 debug[];
};

layout(std430, binding = 10) readonly restrict buffer Adj
{
    int adj[];
};


void usePressureKernel_gradient(vec4 distVector, float supportRadius, out vec4 ret) {
    float dist = length(distVector);
    if (dist > supportRadius) {
        
        ret = vec4(0);
        
    }
    else
    {
        
        vec4 normalized;
        normalized=normalize(distVector);

        ret= -(normalized * (45 / (PI_FLOAT * pow(supportRadius, 6.0f))) * pow(supportRadius - dist, 2.0f));
        
    }
}

bool contains(uint arr[27], int size, uint member) {
    bool ret = false;

    for (int i = 0; i < size; i++)
    {
        ret= (arr[i] == member) || ret; 
        
    }
    return ret;
}

int getAdj(vec4 pos, float H, out uint ret[27]) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;
    int part1, part2, part3;
    int cell[3];
    cell[0] = int(pos.x * UM_SOBRE_H);
    cell[1] = int(pos.y * UM_SOBRE_H);
    cell[2] = int(pos.z * UM_SOBRE_H);

    uint tempBucket;
    int retSize = 0;

    //bucket recebido
    part1 = int(cell[0] * p1);
    part2 = int(cell[1] * p2);
    part3 = int(cell[2] * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    ret[0] = tempBucket;
    
    retSize++;
    //bucket right
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    //tempPosition[0]=vec4(tempBucket);
    if (contains(ret,retSize,tempBucket)==false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1]) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //-----O mesmo mas para os buckets de cima
    //bucket recebido cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left cima
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back cima
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back cima
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front cima
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back cima 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] + 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }


    //-----O mesmo mas para os buckets de baixo
    //bucket recebido baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left baixo
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2]) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right front baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket right back baixo
    part1 = ((cell[0] + 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket front baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket back baixo
    part1 = ((cell[0]) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left front baixo
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] - 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    //bucket left back baixo 
    part1 = ((cell[0] - 1) * p1);
    part2 = ((cell[1] - 1) * p2);
    part3 = ((cell[2] + 1) * p3);
    tempBucket = uint((part1 ^ part2 ^ part3) % HASHSIZE);
    if (contains(ret, retSize, tempBucket) == false) {
        ret[retSize] = tempBucket;
        retSize++;
    }

    

    return retSize;
    
}

float useViscosityKernel_laplacian(vec4 distVector, float supportRadius) {
    float dist = length(distVector);
    if (dist > supportRadius)
        return 0.0f;
    else
        return (45 / (PI_FLOAT * pow(supportRadius, 6.0f))) * (supportRadius - dist);
}

void useDefaultKernel_gradient(vec4 distVector, float supportRadius,out vec4 ret) {
    float dist = length(distVector);
    if (dist > supportRadius) {
        ret = vec4(0);
    }
    else {
        ret = -(distVector * (945 / (32 * PI_FLOAT * pow(supportRadius, 9.0f))) * pow(supportRadius * supportRadius - dist * dist, 2.0f));
    }
}

float useDefaultKernel_laplacian(vec4 distVector, float supportRadius) {
    float dist = length(distVector);
    if (dist > supportRadius)
        return 0.0f;
    else
        return -(945 / (32 * PI_FLOAT * pow(supportRadius, 9.0f))) * (supportRadius * supportRadius - dist * dist) * (3 * supportRadius * supportRadius - 7 * dist * dist);
}

uint hashFunction(vec4 pos,double H,int size) {
    
    int p1 = 2693;
    int p2 = 3163;
    int p3 = 4091;

    int part1 = (int((pos.x / H)) * p1);
    int part2 = (int((pos.y / H)) * p2);
    int part3 = (int ((pos.z / H)) * p3);
    
    uint ret = uint((part1 ^ part2 ^ part3) % size);
    
    return ret;
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

void main()
{
    if (Pause == 1)
        return;
    uint index = gl_GlobalInvocationID.x;
    if (index > Number_Particles)
        return;

    vec4 p =position[index];
    vec4 v = velocity[index];
    float press = pressure[index];
    float dens = density[index];

    
    vec4 sumViscosity = vec4(0);
    vec4 sumForce = vec4(0);
    vec4 sumSurfaceNormal= vec4(0);
    float sum =0;

    
    int count;
    count=0;

    int vizinhos= adj[index*MAXADJ];

    for (int i = 0 ; i< vizinhos ; i ++){
        //Viscosity
        int adji= adj[index*MAXADJ + i + 1];
        if (p.x == position[adji].x && p.y == position[adji].y && p.z == position[adji].z)
                continue;
            vec4 arg;
            arg = p - position[adji];

            //sumViscosity += useViscosityKernel_laplacian(arg, H) * (velocity[adji] - v) * (MASS / density[adji]) ;
            sumViscosity += useViscosityKernel_laplacian(arg, H) * (velocity[adji] - v)*(MASS/density[adji]) ;

            //Force
            vec4 ret_kernel = vec4(0);
            arg = p - position[adji];
            
            usePressureKernel_gradient(arg, H, ret_kernel);
            
            //sumForce += ret_kernel * ((press / (dens * dens)) + (pressure[adji] / (density[adji] * density[adji])));

            //Esta é a formula que esta no kelegar06 equação 4.11
            sumForce += SIMULATIONSCALEFORCE* ret_kernel *((pressure[adji]+press)/(2))*(MASS/density[adji]);
            
            //SurfaceNormal ------------ nao faz diferença

            //vec4 ret2 = vec4(0);
            
            //arg = p- position[adji];
            
            //useDefaultKernel_gradient(arg, H, ret2);
            //sumSurfaceNormal += ret2 * (MASS / density[adji]);
    } 

    viscosity[index]= sumViscosity * (VISCOSITY);
    
    force[index]= -sumForce;

	//add normal force
	vec2 textp = vec2(map(p.x,XMIN,XMAX,0.01,0.99),map(p.z,ZMIN,ZMAX,0.2,0.99));
    float newy = YMIN + texture(river, textp).x;
    
    if (p.y < newy + H){
    	float factor = map(p.y,newy-0.05,newy+H,1,0);
    	//compute normal
	    float tstep =0.001;
	    vec3 top =vec3(p.x,0,p.z+tstep);
	    vec2 temp = vec2(map(top.x,XMIN,XMAX,0.01,0.99),map(top.z,ZMIN,ZMAX,0.2,0.99));
	    top.y = texture(river, vec2(temp.x,temp.y)).x;

	    vec3 bot = vec3(p.x,0,p.z-tstep);
	    temp = vec2(map(bot.x,XMIN,XMAX,0.01,0.99),map(bot.z,ZMIN,ZMAX,0.2,0.99));
	    bot.y= texture(river,vec2(temp.x,temp.y)).x;
	    
	    vec3 left = vec3(p.x-tstep,0,p.z); 
	    temp = vec2(map(left.x,XMIN,XMAX,0.01,0.99),map(left.z,ZMIN,ZMAX,0.2,0.99));
	    left.y= texture(river,vec2(temp.x,temp.y)).x;
	    
	    vec3 right = vec3(p.x+tstep,0,p.z); 
	    temp = vec2(map(right.x,XMIN,XMAX,0.01,0.99),map(right.z,ZMIN,ZMAX,0.2,0.99));
	    right.y= texture(river,vec2(temp.x,temp.y)).x;

	    vec3 v1 = normalize(top-bot);
	    vec3 v2 = normalize(left - right);

	    vec3 n =normalize(cross(v2,v1));

	    vec4 normalv4 = vec4(n.x,n.y,n.z,0);
	    force[index] = force[index] + normalv4 *factor*100000; 	
    }    
    


    //force[index]= -(sumForce*SIMULATIONSCALEFORCE*MASS*dens);

    

    //if (p.y < -2 + H)
    //    force[index].y= 50000;

    //debug[index] = vec4(density[index]);

    //tempp=vec4(sumForce[0],sumForce[1],sumForce[2 ],0);

    //surfaceNormal[index] = sumSurfaceNormal;

    //gravity[index] = GRAVITY * density[index];


    /*    Surface tension nao faz diferença no resultado quase

    if (length(surfaceNormal[index]) >= THRESHOLD) {

        for (int i = 0 ; i< vizinhos ; i ++){
            int adji= adj[index*MAXADJ + i + 1];
            if (p.x == position[adji].x && p.y == position[adji].y && p.z == position[adji].z)
                continue;
            vec4 arg;
            arg = p - position[adji];
            sum += (MASS / density[adji]) * useDefaultKernel_laplacian(arg, H);
        }
            
            
           

            vec4 surfaceNormalNormalized;

            surfaceNormalNormalized=normalize(surfaceNormal[index]);
            
            surfaceTension[index]= -(surfaceNormalNormalized * SURFACETENSION * sum);

        }
        else {
            surfaceTension[index]= vec4(0);
        }
    */
}